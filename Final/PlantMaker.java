import java.util.*;

/** PlantMaker - uses an L-system model (of a plant) to generate a String
 * 
 *
 */

public class PlantMaker {

    Integer seed = 31234;
    boolean diag = false;
    Random r;

	/** makePlant - generate a String, given a plant, a depthLimit and a percent
	 * 
	 * @param plant (APlant) - provides axiom and rules  there should only be one rule for each header (but see below)
	 * @param depthLimit - simultaneous replacement will take place this many times
	 * @param percent (between 0.0 and 1.0) - if this is 1.0, all instances of the head of the rule are replaced, otherwise heads
	 * are replaced with (approximate) frequency percent 
	 * @return string generated by L system
	 * 
	 * ifthe plant (APlant) is AProbPlant, then the Plant should provide the percentage on a per-rule basis. 
	 */

    

    public void setSeed(Integer i) {
	if (i == null)
	    seed = null;
	else seed = i;
    }

    public String makePlant(APlant plant, int depthLimit, double percent) {
	if (seed == null)
	    r = new Random();
	else r = new Random(seed);
	MarkedString axiom = new MarkedString(plant.getAxiom(),'o');
		String[] rules = plant.getRules();

		int count=0;
		while (true) {
			count++;

			for (String rule : rules) {
				String ruleHead = rule.substring(0,1);
				MarkedString ruleTail = new MarkedString(rule.substring(1),'n');

				double outProb = plant.getProb(rule);
				if (outProb != -1)
					percent = outProb;
				
				axiom = specReplace(axiom,ruleHead,ruleTail,percent);
				//System.out.println(axiom);
			}
			if (diag) System.out.println("Outer"+axiom.length());
			axiom.reset('o');
			//System.out.println("depth "+count+" "+depthLimit);
			if (count >= depthLimit) break;
		}


		if (diag) {
			System.out.println("Final String: "+axiom);
			System.exit(0);	
		}
		return axiom.s;
	}

	private MarkedString specReplace(MarkedString old, String head, MarkedString tail, double prob) {

		MarkedString ret;

		ret = old;

		if (old.s.indexOf(head) == -1)
			return old;

		Vector<Integer> wheres = new Vector<Integer>();

		int where = old.s.indexOf(head);

		while (where != -1) {
			if (old.marks.charAt(where) == 'o')
				wheres.add(0,where);
			where = old.s.indexOf(head,where+1);
		}

		for (Integer w : wheres) {
			//System.out.println(w);
			//System.out.println(ret);
			if (w != ret.s.length()-1)
			    {if (r.nextDouble() < prob)
				ret = ret.substring(0,w).append(tail).append(ret.substring(w+1,ret.length()));
			}
			else
			    {if (r.nextDouble() < prob)
				ret = ret.substring(0,w).append(tail);
			}
			//System.out.println(ret);
		}

		return ret;
	}


	public static void main(String args[]) {

		MarkedString s = new PlantMaker().specReplace(
				new MarkedString("AAA","ono"),
				"A",
				new MarkedString("BA",'n'),0.9);
		System.out.println(s.s+"  +"+s.marks);

	}

}

class MarkedString {

	String s;
	String marks;

	MarkedString(String s1, char m) {
		s = s1;
		marks = "";
		for (byte c : s.getBytes()) {
			marks = marks+m;
		}
	}

	public void reset(char m) {
		marks = "";
		for (byte c : s.getBytes()) {
			marks = marks+m;
		}
		
	}

	public MarkedString append(MarkedString tail) {
		s = s + tail.s;
		marks = marks+tail.marks;
		return this;
	}

	public int length() {
		return s.length();
	}

	MarkedString(String s1, 
			String m) {
		this.s = s1;
		this.marks = m;
	}

	public String toString() {
		return "MS "+s+":"+marks;
	}

	public MarkedString substring(int i, int w) {	
		return new MarkedString(s.substring(i,w),marks.substring(i,w));
	}
}
