// public ArrayList<Intersection> local_intersect(Ray r1) {
//     // Transform the ray by the inverse of the Traceable transform before intersecting
//     Ray r = r1.transform(this.transform.inverse());
    
//     // Calculate a, b and c as in class. Be careful about using the ray origin,
//     // which is a point - don't accidentally get an extra 1 from the w coordinate
//     Vector sphereToRay = r.origin.subtract(new Point(0, 0, 0));
//     double a = r.direction.dot(r.direction);
//     double b = 2 * r.direction.dot(sphereToRay);
//     double c = sphereToRay.dot(sphereToRay) - 1;
    
//     // Use the discriminant to decide what to return in ans -
//     // it should be empty if there are no intersections (not null)
//     ArrayList<Intersection> ans = new ArrayList<Intersection>();
//     double discriminant = b * b - 4 * a * c;
//     if (discriminant < 0) {
//         return ans;
//     }
    
//     // Fill in the intersections
//     double t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
//     double t2 = (-b + Math.sqrt(discriminant)) / (2 * a);
//     ans.add(new Intersection(t1, this));
//     ans.add(new Intersection(t2, this));
    
//     return ans;
// } Point p = new Point(0, 0, 0);
// Tuple sphereToRay = Tuple.sub(p, r.origin);
// double a = Tuple.dot(r.direction, r.direction);
// double b = 2 * Tuple.dot(r.direction, sphereToRay);
// double c = Tuple.dot(sphereToRay,sphereToRay) - 1;

// ArrayList<Intersection> ans = new ArrayList<Intersection>();
// double discriminant = b * b - 4 * a * c;
// if (discriminant < 0) {
//     return ans;
// }

// // Fill in the intersections
// double t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
// double t2 = (-b + Math.sqrt(discriminant)) / (2 * a);
// ans.add(new Intersection(t1, this));
// ans.add(new Intersection(t2, this));

// return ans;
// }
